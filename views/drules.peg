Type <- TypeCtors? BasicType;
TypeCtors <- TypeCtor+;
TypeCtor <- "shared" / "inout" / "immutable" / "const";
BasicType <- TypeCtor "(" Type ")" / Typeof "." IdentifierList / Typeof / IdentifierList / "." IdentifierList / BasicTypeX;
BasicTypeX <- "void" / "creal" / "cdouble" / "cfloat" / "ireal" / "idouble" / "ifloat" / "real" / "double" / "float" / "dchar" / "wchar" / "char" / "ulong" / "long" / "uint" / "int" / "ushort" / "short" / "ubyte" / "byte" / "bool";
BasicType2 <- "function" Parameters FunctionAttributes? / "delegate" Parameters MemberFunctionAttributes? / "[" Type "]" / "[" AssignExpression ".." AssignExpression "]" / "[" AssignExpression "]" / "[" "]" / "*";
IdentifierList <- TemplateInstance "." IdentifierList / TemplateInstance / Identifier "." IdentifierList / Identifier;
Typeof <- "typeof" "(" "return" ")" / "typeof" "(" Expression ")";
Expression <- CommaExpression;
CommaExpression <- AssignExpression "," CommaExpression / AssignExpression;
AssignExpression <- ConditionalExpression "^^=" AssignExpression / ConditionalExpression ">>>=" AssignExpression / ConditionalExpression ">>=" AssignExpression / ConditionalExpression "<" "<" "=" AssignExpression / ConditionalExpression "~=" AssignExpression / ConditionalExpression "^=" AssignExpression / ConditionalExpression "|=" AssignExpression / ConditionalExpression "&=" AssignExpression / ConditionalExpression "%=" AssignExpression / ConditionalExpression "/=" AssignExpression / ConditionalExpression "*=" AssignExpression / ConditionalExpression "-=" AssignExpression / ConditionalExpression "+=" AssignExpression / ConditionalExpression "=" AssignExpression / ConditionalExpression;
ConditionalExpression <- OrOrExpression "?" Expression ":" ConditionalExpression / OrOrExpression;
OrOrExpression <- AndAndExpression / OrOrExpression "||" AndAndExpression;
AndAndExpression <- AndAndExpression "&&" CmpExpression / AndAndExpression "&&" OrExpression / CmpExpression / OrExpression;
OrExpression <- XorExpression / OrExpression "|" XorExpression;
XorExpression <- AndExpression / XorExpression "^" AndExpression;
AndExpression <- AndExpression "&" ShiftExpression / ShiftExpression ;
CmpExpression <- InExpression / RelExpression / IdentityExpression / EqualExpression / ShiftExpression;
EqualExpression <- ShiftExpression "!=" ShiftExpression / ShiftExpression "==" ShiftExpression;
IdentityExpression <- ShiftExpression "!is" ShiftExpression / ShiftExpression "is" ShiftExpression;
RelExpression <- ShiftExpression "!<=" ShiftExpression / ShiftExpression "!<" ShiftExpression / ShiftExpression "!>=" ShiftExpression / ShiftExpression "!>" ShiftExpression / ShiftExpression "<>=" ShiftExpression / ShiftExpression "<>" ShiftExpression / ShiftExpression "!<>" ShiftExpression / ShiftExpression "!<>=" ShiftExpression / ShiftExpression ">=" ShiftExpression / ShiftExpression ">" ShiftExpression / ShiftExpression "<=" ShiftExpression / ShiftExpression "<" ShiftExpression;
InExpression <- ShiftExpression "!in" ShiftExpression / ShiftExpression "in" ShiftExpression;
ShiftExpression <- AddExpression / ShiftExpression ">>>" AddExpression / ShiftExpression ">>" AddExpression / ShiftExpression "<<" AddExpression;
AddExpression <- AddExpression "~" MulExpression / AddExpression "-" MulExpression / AddExpression "+" MulExpression / MulExpression;
MulExpression <- MulExpression "%" UnaryExpression / MulExpression "/" UnaryExpression / MulExpression "*" UnaryExpression / UnaryExpression;
UnaryExpression <- PowExpression / CastExpression / DeleteExpression / "(" Type ")" "." TemplateInstance / "(" Type ")" "." Identifier / ComplementExpression / "!" UnaryExpression / "+" UnaryExpression / "-" UnaryExpression / "*" UnaryExpression / "--" UnaryExpression / "++" UnaryExpression / "&" UnaryExpression;
ComplementExpression <- "~" UnaryExpression;
NewExpression <- NewExpressionWithArgs / "new" AllocatorArguments? Type;
NewExpressionWithArgs <- NewAnonClassExpression / "new" AllocatorArguments? Type "(" ArgumentList? ")" / "new" AllocatorArguments? Type "[" AssignExpression "]";
AllocatorArguments <- "(" ArgumentList? ")";
ArgumentList <- AssignExpression "," ArgumentList / AssignExpression "," / AssignExpression;
NewAnonClassExpression <- "new" AllocatorArguments? "class" ClassArguments? SuperClass? Interfaces? AggregateBody;
ClassArguments <- "(" ArgumentList? ")";
DeleteExpression <- "delete" UnaryExpression;
CastExpression <- "cast" "(" TypeCtors? ")" UnaryExpression / "cast" "(" Type ")" UnaryExpression;
PowExpression <- PostfixExpression "^^" UnaryExpression / PostfixExpression;
PostfixExpression <- TypeCtors BasicType "(" ArgumentList? ")" / PostfixExpression "[" AssignExpression ".." AssignExpression "]" / PostfixExpression "[" "]" / PostfixExpression "[" ArgumentList "]" / PostfixExpression "(" ArgumentList? ")" / PostfixExpression "--" / PostfixExpression "++" / PostfixExpression "." NewExpression / PostfixExpression "." TemplateInstance / PostfixExpression "." Identifier / PrimaryExpression;
PrimaryExpression <- SpecialKeyword / TraitsExpression / "(" Expression ")" / IsExpression / TypeidExpression / Typeof / BasicTypeX "." Identifier / NewExpressionWithArgs / ImportExpression / MixinExpression / AssertExpression / FunctionLiteral / AssocArrayLiteral / ArrayLiteral / StringLiterals / CharacterLiteral / FloatLiteral / IntegerLiteral / "$" / "false" / "true" / "null" / "super" / "this" / "." TemplateInstance / TemplateInstance / "." Identifier / Identifier;
StringLiterals <- StringLiteral+;
ArrayLiteral <- "[" ArgumentList? "]";
AssocArrayLiteral <- "[" KeyValuePairs "]";
KeyValuePairs <- KeyValuePair ("," KeyValuePair)*;
KeyValuePair <- KeyExpression ":" ValueExpression;
KeyExpression <- AssignExpression;
ValueExpression <- AssignExpression;
FunctionLiteral <- Lambda / FunctionLiteralBody / ParameterAttributes FunctionLiteralBody / "delegate" Type? ParameterAttributes? FunctionLiteralBody / "function" Type? ParameterAttributes? FunctionLiteralBody;
ParameterAttributes <- Parameters FunctionAttributes / Parameters;
FunctionLiteralBody <- FunctionContracts? BodyStatement / BlockStatement;
Lambda <- Identifier "=>" AssignExpression / ParameterAttributes "=>" AssignExpression / "delegate" Type? ParameterAttributes "=>" AssignExpression / "function" Type? ParameterAttributes "=>" AssignExpression;
AssertExpression <- "assert" "(" AssignExpression "," AssignExpression ")" / "assert" "(" AssignExpression ")";
MixinExpression <- "mixin" "(" AssignExpression ")";
ImportExpression <- "import" "(" AssignExpression ")";
TypeidExpression <- "typeid" "(" Expression ")" / "typeid" "(" Type ")";
IsExpression <- "is" "(" Type Identifier "==" TypeSpecialization "," TemplateParameterList ")" / "is" "(" Type Identifier ":" TypeSpecialization "," TemplateParameterList ")" / "is" "(" Type Identifier "==" TypeSpecialization ")" / "is" "(" Type Identifier ":" TypeSpecialization ")" / "is" "(" Type Identifier ")" / "is" "(" Type "==" TypeSpecialization "," TemplateParameterList ")" / "is" "(" Type ":" TypeSpecialization "," TemplateParameterList ")" / "is" "(" Type "==" TypeSpecialization ")" / "is" "(" Type ":" TypeSpecialization ")" / "is" "(" Type ")";
TypeSpecialization <- "__parameters" / "return" / "shared" / "inout" / "immutable" / "const" / "super" / "delegate" / "function" / "enum" / "interface" / "class" / "union" / "struct" / Type;
TraitsExpression <- "__traits" "(" TraitsKeyword "," TraitsArguments ")";
TraitsKeyword <- "compiles" / "isSame" / "derivedMembers" / "allMembers" / "getVirtualIndex" / "classInstanceSize" / "parent" / "getUnitTests" / "getVirtualMethods" / "getVirtualFunctions" / "getProtection" / "getOverloads" / "getMember" / "getAttributes" / "getAliasThis" / "identifier" / "hasMember" / "isLazy" / "isOut" / "isRef" / "isOverrideFunction" / "isStaticFunction" / "isFinalFunction" / "isAbstractFunction" / "isVirtualMethod" / "isVirtualFunction" / "isUnsigned" / "isStaticArray" / "isScalar" / "isIntegral" / "isFloating" / "isNested" / "isPOD" / "isFinalClass" / "isAssociativeArray" / "isArithmetic" / "isAbstractClass";
TraitsArguments <- TraitsArgument ("," TraitsArgument)*;
TraitsArgument <- Type / AssignExpression;
SpecialKeyword <- "__PRETTY_FUNCTION__" / "__FUNCTION__" / "__LINE__" / "__MODULE__" / "__FILE__";
Statement <- ScopeBlockStatement / NonEmptyStatement / ";";
NoScopeNonEmptyStatement <- BlockStatement / NonEmptyStatement;
NoScopeStatement <- BlockStatement / NonEmptyStatement / ";";
NonEmptyOrScopeBlockStatement <- ScopeBlockStatement / NonEmptyStatement;
NonEmptyStatement <- DefaultStatement / CaseRangeStatement / CaseStatement / NonEmptyStatementNoCaseNoDefault;
NonEmptyStatementNoCaseNoDefault <- ImportDeclaration / TemplateMixin / StaticAssert / ConditionalStatement / ForeachRangeStatement / MixinStatement / PragmaStatement / ThrowStatement / ScopeGuardStatement / TryStatement / SynchronizedStatement / WithStatement / GotoStatement / ReturnStatement / BreakStatement / ContinueStatement / FinalSwitchStatement / SwitchStatement / ForeachStatement / ForStatement / DoStatement / WhileStatement / IfStatement / DeclarationStatement / ExpressionStatement / LabeledStatement;
ScopeStatement <- BlockStatement / NonEmptyStatement;
ScopeBlockStatement <- BlockStatement;
LabeledStatement <- Identifier ":" Statement / Identifier ":" NoScopeStatement / Identifier ":";
BlockStatement <- "{" StatementList "}" / "{" "}";
StatementList <- Statement StatementList / Statement;
ExpressionStatement <- Expression ";";
DeclarationStatement <- Declaration;
IfStatement <- "if" "(" IfCondition ")" ThenStatement "else" ElseStatement / "if" "(" IfCondition ")" ThenStatement;
IfCondition <- TypeCtors? BasicType Declarator "=" Expression / TypeCtors Identifier "=" Expression / "auto" Identifier "=" Expression / Expression;
ThenStatement <- ScopeStatement;
ElseStatement <- ScopeStatement;
WhileStatement <- "while" "(" Expression ")" ScopeStatement;
DoStatement <- "do" ScopeStatement "while" "(" Expression ")" ";";
ForStatement <- "for" "(" Initialize Test? ";" Increment? ")" ScopeStatement;
Initialize <- NoScopeNonEmptyStatement / ";";
Test <- Expression;
Increment <- Expression;
ForeachStatement <- Foreach "(" ForeachTypeList ";" ForeachAggregate ")" NoScopeNonEmptyStatement;
Foreach <- "foreach_reverse" / "foreach";
ForeachTypeList <- ForeachType ("," ForeachType)*;
ForeachType <- "ref"? TypeCtors? Identifier / "ref"? TypeCtors? BasicType Declarator;
ForeachAggregate <- Expression;
ForeachRangeStatement <- Foreach "(" ForeachType ";" LwrExpression ".." UprExpression ")" ScopeStatement;
LwrExpression <- Expression;
UprExpression <- Expression;
SwitchStatement <- "switch" "(" Expression ")" ScopeStatement;
CaseStatement <- "case" ArgumentList ":" ScopeStatementList;
CaseRangeStatement <- "case" FirstExp ":" ".." "case" LastExp ":" ScopeStatementList;
FirstExp <- AssignExpression;
LastExp <- AssignExpression;
DefaultStatement <- "default" ":" ScopeStatementList;
ScopeStatementList <- StatementListNoCaseNoDefault;
StatementListNoCaseNoDefault <- StatementNoCaseNoDefault StatementListNoCaseNoDefault / StatementNoCaseNoDefault;
StatementNoCaseNoDefault <- ScopeBlockStatement / NonEmptyStatementNoCaseNoDefault / ";";
FinalSwitchStatement <- "final" "switch" "(" Expression ")" ScopeStatement;
ContinueStatement <- "continue" Identifier? ";";
BreakStatement <- "break" Identifier? ";";
ReturnStatement <- "return" Expression? ";";
GotoStatement <- "goto" "case" Expression ";" / "goto" "case" ";" / "goto" "default" ";" / "goto" Identifier ";";
WithStatement <- "with" "(" TemplateInstance ")" ScopeStatement / "with" "(" Symbol ")" ScopeStatement / "with" "(" Expression ")" ScopeStatement;
SynchronizedStatement <- "synchronized" "(" Expression ")" ScopeStatement / "synchronized" ScopeStatement;
TryStatement <- "try" ScopeStatement FinallyStatement / "try" ScopeStatement Catches FinallyStatement / "try" ScopeStatement Catches;
Catches <- Catch Catches / Catch / LastCatch;
LastCatch <- "catch" NoScopeNonEmptyStatement;
Catch <- "catch" "(" CatchParameter ")" NoScopeNonEmptyStatement;
CatchParameter <- BasicType Identifier;
FinallyStatement <- "finally" NoScopeNonEmptyStatement;
ThrowStatement <- "throw" Expression ";";
ScopeGuardStatement <- "scope" "(" "failune" ")" NonEmptyOrScopeBlockStatement / "scope" "(" "success" ")" NonEmptyOrScopeBlockStatement / "scope" "(" "exit" ")" NonEmptyOrScopeBlockStatement;
PragmaStatement <- Pragma NoScopeStatement;
MixinStatement <- "mixin" "(" AssignExpression ")" ";";
Declaration <- AliasDeclaration / ImportDeclaration / EnumDeclaration / AggregateDeclaration / VarDeclarations / FuncDeclaration;
AliasDeclaration <- "alias" AliasDeclarationX ";" / "alias" StorageClasses? BasicType FuncDeclarator ";" / "alias" StorageClasses? BasicType Declarator ";";
AliasDeclarationX <- AliasDeclarationX "," Identifier TemplateParameters? "=" StorageClasses? Type / Identifier TemplateParameters? "=" StorageClasses? Type;
AutoDeclaration <- StorageClasses AutoDeclarationX ";";
AutoDeclarationX <- AutoDeclarationX "," Identifier TemplateParameters? "=" Initializer / Identifier TemplateParameters? "=" Initializer;
VarDeclarations <- AutoDeclaration / StorageClasses? BasicType Declarators ";";
Declarators <- DeclaratorInitializer ("," DeclaratorInitializer)*;
DeclaratorInitializer <- VarDeclarator TemplateParameters? "=" Initializer / VarDeclarator;
Declarator <- VarDeclarator;
VarDeclarator <- BasicType2? Identifier;
StorageClasses <- StorageClass StorageClasses / StorageClass;
StorageClass <- "ref" / "pure" / "nothrow" / Property / "__gshared" / "shared" / "inout" / "immutable" / "const" / "scope" / "auto" / "synchronized" / "override" / "final" / "abstract" / "extern" / "static" / "enum" / "deprecated" / AlignAttribute / LinkageAttribute;
Initializer <- NonVoidInitializer / VoidInitializer;
VoidInitializer <- "void";
NonVoidInitializer <- StructInitializer / ArrayInitializer / ExpInitializer;
ExpInitializer <- AssignExpression;
ArrayInitializer <- "[" ArrayMemberInitializations? "]";
ArrayMemberInitializations <- ArrayMemberInitialization ("," ArrayMemberInitialization)* ","?;
ArrayMemberInitialization <- AssignExpression ":" NonVoidInitializer / NonVoidInitializer;
StructInitializer <- "{" StructMemberInitializers? "}";
StructMemberInitializers <- StructMemberInitializer ("," StructMemberInitializers)* ","?;
StructMemberInitializer <- Identifier ":" NonVoidInitializer / NonVoidInitializer;
FuncDeclaration <- AutoFuncDeclaration / StorageClasses? BasicType FuncDeclarator FunctionBody;
AutoFuncDeclaration <- StorageClasses Identifier FuncDeclaratorSuffix FunctionBody;
FuncDeclarator <- BasicType2? Identifier FuncDeclaratorSuffix;
FuncDeclaratorSuffix <- TemplateParameters Parameters MemberFunctionAttributes? Constraint? / Parameters MemberFunctionAttributes?;
Parameters <- "(" ParameterList? ")";
ParameterList <- "..." / Parameter ("," Parameter)*;
Parameter <-  InOut? BasicType Declarator "=" AssignExpression / InOut? BasicType Declarator "..." / InOut? BasicType Declarator / InOut? Type "..." / InOut? Type;
InOut <- InOut InOutX / InOutX;
InOutX <- "scope" / "ref" / "out" / "lazy" / "in" / "final" / TypeCtor / "auto";
FunctionAttributes <- FunctionAttribute+;
FunctionAttribute <- Property / "pure" / "nothrow";
MemberFunctionAttributes <- MemberFunctionAttribute+;
MemberFunctionAttribute <- FunctionAttribute / "shared" / "inout" / "immutable" / "const";
FunctionBody <- FunctionContracts / FunctionContracts? BodyStatement / BlockStatement;
FunctionContracts <- OutStatement InStatement? / InStatement OutStatement?;
InStatement <- "in" BlockStatement;
OutStatement <- "out" "(" Identifier ")" BlockStatement / "out" BlockStatement;
BodyStatement <- "body" BlockStatement;
Constructor <- ConstructorTemplate / "this" Parameters MemberFunctionAttributes? FunctionBody / "this" Parameters MemberFunctionAttributes? ";";
ConstructorTemplate <- "this" TemplateParameters Parameters MemberFunctionAttributes? Constraint? FunctionBody / "this" TemplateParameters Parameters MemberFunctionAttributes? Constraint? ";";
Destructor <- "~" "this" "(" ")" MemberFunctionAttributes? FunctionBody / "~" "this" "(" ")" MemberFunctionAttributes? ";";
Postblit <- "this" "(" "this" ")" MemberFunctionAttributes? FunctionBody / "this" "(" "this" ")" MemberFunctionAttributes? ";";
Allocator <- "new" Parameters FunctionBody / "new" Parameters ";";
Deallocator <- "delete" Parameters FunctionBody / "delete" Parameters ";";
Invariant <- "invariant" "(" ")" BlockStatement;
UnitTest <- "unittest" BlockStatement;
StaticConstructor <- "static" "this" "(" ")" FunctionBody / "static" "this" "(" ")" ";";
StaticDestructor <- "static" "~" "this" "(" ")" MemberFunctionAttributes? FunctionBody / "static" "~" "this" "(" ")" MemberFunctionAttributes? ";";
SharedStaticConstructor <- "shared" "static" "this" "(" ")" FunctionBody / "shared" "static" "this" "(" ")" ";";
SharedStaticDestructor <- "shared" "static" "~" "this" "(" ")" MemberFunctionAttributes? FunctionBody / "shared" "static" "~" "this" "(" ")" MemberFunctionAttributes? ";";
AggregateDeclaration <- UnionDeclaration / StructDeclaration / InterfaceDeclaration / ClassDeclaration;
ClassDeclaration <- ClassTemplateDeclaration / "class" Identifier BaseClassList? AggregateBody / "class" Identifier ";";
ClassTemplateDeclaration <- "class" Identifier TemplateParameters BaseClassList Constraint AggregateBody / "class" Identifier TemplateParameters Constraint? BaseClassList? AggregateBody;
InterfaceDeclaration <- InterfaceTemplateDeclaration / "interface" Identifier BaseInterfaceList? AggregateBody / "interface" Identifier ";";
InterfaceTemplateDeclaration <- "interface" Identifier TemplateParameters BaseInterfaceList Constraint AggregateBody / "interface" Identifier TemplateParameters Constraint? BaseInterfaceList? AggregateBody;
StructDeclaration <- AnonStructDeclaration / StructTemplateDeclaration / "struct" Identifier AggregateBody / "struct" Identifier ";";
StructTemplateDeclaration <- "struct" Identifier TemplateParameters Constraint? AggregateBody;
AnonStructDeclaration <- "struct" AggregateBody;
UnionDeclaration <- AnonUnionDeclaration / UnionTemplateDeclaration / "union" Identifier AggregateBody / "union" Identifier ";";
UnionTemplateDeclaration <- "union" Identifier TemplateParameters Constraint? AggregateBody;
AnonUnionDeclaration <- "union" AggregateBody;
AggregateBody <- "{" DeclDefs? "}";
BaseClassList <- ":" Interfaces / ":" SuperClass "," Interfaces / ":" SuperClass;
BaseInterfaceList <- ":" Interfaces;
SuperClass <- BasicType;
Interfaces <- Interface ("," Interface)*;
Interface <- BasicType;
AliasThis <- "alias" Identifier "this" ";";
EnumDeclaration <- "enum" ":" EnumBaseType EnumBody / "enum" EnumTag ":" EnumBaseType EnumBody / "enum" EnumBody / "enum" EnumTag EnumBody;
EnumTag <- Identifier;
EnumBaseType <- Type;
EnumBody <- EnumMembersBody / EmptyEnumBody;
EmptyEnumBody <- ";";
EnumMembersBody <- "{" EnumMembers "}";
EnumMembers <- EnumMember ("," EnumMember)* ","?;
EnumMember <- Type Identifier "=" AssignExpression / Identifier "=" AssignExpression / Identifier;
TemplateDeclaration <- "template" Identifier TemplateParameters Constraint? "{" DeclDefs? "}";
TemplateParameters <- "(" TemplateParameterList? ")";
TemplateParameterList <- TemplateParameter ("," TemplateParameter)* ","?;
TemplateParameter <- TemplateThisParameter / TemplateTupleParameter / TemplateAliasParameter / TemplateValueParameter / TemplateTypeParameter;
Constraint <- "if" "(" Expression ")";
TemplateInstance <- Identifier TemplateArguments;
TemplateArguments <- "!" TemplateSingleArgument / "!" "(" TemplateArgumentList? ")";
TemplateArgumentList <- TemplateArgument ("," TemplateArgument)* ","?;
TemplateArgument <- Symbol / AssignExpression / Type;
Symbol <- "." SymbolTail / SymbolTail;
SymbolTail <- TemplateInstance "." SymbolTail / TemplateInstance / Identifier "." SymbolTail / Identifier;
TemplateSingleArgument <- SpecialKeyword / "this" / "null" / "false" / "true" / FloatLiteral / IntegerLiteral / StringLiteral / CharacterLiteral / BasicTypeX / Identifier;
TemplateTypeParameter <- Identifier TemplateTypeParameterSpecialization TemplateTypeParameterDefault / Identifier TemplateTypeParameterDefault / Identifier TemplateTypeParameterSpecialization / Identifier;
TemplateTypeParameterSpecialization <- ":" Type;
TemplateTypeParameterDefault <- "=" Type;
TemplateThisParameter <- "this" TemplateTypeParameter;
TemplateValueParameter <- BasicType Declarator TemplateValueParameterSpecialization TemplateValueParameterDefault / BasicType Declarator TemplateValueParameterDefault / BasicType Declarator TemplateValueParameterSpecialization / BasicType Declarator;
TemplateValueParameterSpecialization <- ":" ConditionalExpression;
TemplateValueParameterDefault <- "=" SpecialKeyword / "=" AssignExpression;
TemplateAliasParameter <- "alias" BasicType Declarator TemplateAliasParameterSpecialization? TemplateAliasParameterDefault? / "alias" Identifier TemplateAliasParameterSpecialization? TemplateAliasParameterDefault?;
TemplateAliasParameterSpecialization <- ":" ConditionalExpression / ":" Type;
TemplateAliasParameterDefault <- "=" ConditionalExpression / "=" Type;
TemplateTupleParameter <- Identifier "...";
TemplateMixinDeclaration <- "mixin" "template" Identifier TemplateParameters Constraint? "{" DeclDefs? "}";
TemplateMixin <- "mixin" MixinTemplateName TemplateArguments? Identifier? ";";
MixinTemplateName <- Typeof "." QualifiedIdentifierList / QualifiedIdentifierList / "." QualifiedIdentifierList;
QualifiedIdentifierList <- TemplateInstance "." QualifiedIdentifierList / Identifier "." QualifiedIdentifierList / Identifier;
AttributeSpecifier <- Attribute DeclarationBlock / Attribute ":";
Attribute <- "ref" / "pure" / "nothrow" / Property / "__gshared" / "shared" / "inout" / "immutable" / "const" / "scope" / "auto" / "synchronized" / "override" / "final" / "abstract" / "extern" / "static" / Pragma / ProtectionAttribute / DeprecatedAttribute / AlignAttribute / LinkageAttribute;
DeclarationBlock <- "{" DeclDefs? "}" / DeclDef;
LinkageAttribute <- "extern" "(" "C++" "," IdentifierList ")" / "extern" "(" LinkageType ")";
LinkageType <- "System" / "Pascal" / "Windows" / "D" / "C++" / "C";
AlignAttribute <- "align" "(" IntegerLiteral ")" / "align";
DeprecatedAttribute <- "deprecated" "(" StringLiteral ")" / "deprecated";
ProtectionAttribute <- "export" / "public" / "protected" / "package" "(" IdentifierList ")" / "package" / "private";
Property <- UserDefinedAttribute / "@" PropertyIdentifier;
PropertyIdentifier <- "nogc" / "disable" / "system" / "trusted" / "safe" / "property";
UserDefinedAttribute <- "@" TemplateInstance "(" ArgumentList? ")" / "@" TemplateInstance / "@" Identifier "(" ArgumentList? ")" / "@" Identifier / "@" "(" ArgumentList ")";
Pragma <- "pragma" "(" Identifier "," ArgumentList ")" / "pragma" "(" Identifier ")";
ConditionalDeclaration <- Condition DeclarationBlock "else" ":" DeclDefs? / Condition ":" DeclDefs? / Condition DeclarationBlock "else" DeclarationBlock / Condition DeclarationBlock;
ConditionalStatement <- Condition NoScopeNonEmptyStatement "else" NoScopeNonEmptyStatement / Condition NoScopeNonEmptyStatement;
Condition <- StaticIfCondition / DebugCondition / VersionCondition;
VersionCondition <- "version" "(" "assert" ")" / "version" "(" "unittest" ")" / "version" "(" Identifier ")" / "version" "(" IntegerLiteral ")";
DebugCondition <- "debug" "(" Identifier ")" / "debug" "(" IntegerLiteral ")" / "debug";
StaticIfCondition <- "static" "if" "(" AssignExpression ")";
VersionSpecification <- "version" "=" IntegerLiteral ";" / "version" "=" Identifier ";";
DebugSpecification <- "debug" "=" IntegerLiteral ";" / "debug" "=" Identifier ";";
StaticAssert <- "static" "assert" "(" AssignExpression "," AssignExpression ")" ";" / "static" "assert" "(" AssignExpression ")" ";";
Module <- DeclDefs / ModuleDeclaration DeclDefs;
DeclDefs <- DeclDef+;
DeclDef <- ";" / MixinDeclaration / TemplateMixin / TemplateMixinDeclaration / TemplateDeclaration / StaticAssert / VersionSpecification / DebugSpecification / ConditionalDeclaration / SharedStaticDestructor / SharedStaticConstructor / StaticDestructor / StaticConstructor / AliasThis / UnitTest / Invariant / Deallocator / Allocator / Postblit / Destructor / Constructor / Declaration / AttributeSpecifier;
ModuleDeclaration <- "module" ModuleFullyQualifiedName ";";
ModuleFullyQualifiedName <- ModuleName ("." ModuleName)*;
ModuleName <- Identifier;
ImportDeclaration <- "static import" ImportList ";" / "import" ImportList ";";
ImportList <- Import "," ImportList / ImportBindings / Import;
Import <- ModuleAliasIdentifier "=" ModuleFullyQualifiedName / ModuleFullyQualifiedName;
ImportBindings <- Import ":" ImportBindList;
ImportBindList <- ImportBind ("," ImportBind)*;
ImportBind <- Identifier "=" Identifier / Identifier;
ModuleAliasIdentifier <- Identifier;
MixinDeclaration <- "mixin" "(" AssignExpression ")" ";";
